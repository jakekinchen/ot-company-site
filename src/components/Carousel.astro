---
// Carousel.astro
import type { Clients } from '../types';

interface Props {
  pauseOnHover?: boolean;
  clients: Clients[];
  scale?: number;
  duration?: number;
  scroll?: boolean;
  sideBlur?: boolean;
}

const { pauseOnHover = true, clients = [], scale = 1, duration = 35, scroll = false, sideBlur=true } = Astro.props;
---

<div class="logos-wrapper">
  <div 
    class={`logos ${pauseOnHover ? 'pause-on-hover' : ''} ${scroll ? 'scrollable' : ''}`} 
    style={`--scale: ${scale}; --duration: ${duration}; --blur-color: rgba(200,200,200,0.8)`}
  >
    <div class="logos-slide">
      {clients.map((client) => (
        <a href={client.href} target="_blank" rel="noopener noreferrer" style={`--client-scale: ${client.scale};`} aria-label={`Visit ${client.label} website`}>
          <img src={client.iconSrc} alt={client.alt} title={client.label}  />
        </a>
      ))}
    </div>
  </div>
  {sideBlur && (
    <>
      <div class="blur-left"></div>
      <div class="blur-right"></div>
    </>
  )}
</div>

<script>
  const logosContainers = document.querySelectorAll('.logos.scrollable');
  const activeAnimations = new Map();
  
  const cleanup = () => {
    activeAnimations.forEach((animationId) => {
      cancelAnimationFrame(animationId);
    });
    activeAnimations.clear();
  };

  // Cleanup on page unload or visibility change
  window.addEventListener('beforeunload', cleanup);
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      cleanup();
    }
  });

  logosContainers.forEach(container => {
    const slide = container.querySelector('.logos-slide');
    if (!slide) return; // Skip if slide element not found
    
    let isMouseOver = false;
    let animationFrame = 0;
    let lastScrollPosition = 0;
    let scrollDirection = 1;


         let clones = 1;
     
     const cloneLogos = () => {
       const logos = slide.innerHTML;
       // Clone until total width > visible width * 3
       while (slide.scrollWidth < container.clientWidth * 3) {
         slide.insertAdjacentHTML('beforeend', logos);
         clones += 1;
       }
       // Centre on the second set
       const oneSetWidth = slide.scrollWidth / clones;
       container.scrollLeft = oneSetWidth;
     }

    const updateScroll = () => {
      // Only check mouse state if pauseOnHover is enabled
      const shouldPause = isMouseOver && container.classList.contains('pause-on-hover');
      
      // Calculate pixels per frame for both scrolling and reset logic
      const cssduration = parseFloat(getComputedStyle(container).getPropertyValue('--duration')) || 35;
      const pixelsPerFrame = Math.max(0.5, 300 / cssduration);
      
      if (!shouldPause) {
        // Use the duration parameter to control scroll duration (pixels per frame)
        // Convert CSS duration (which is in seconds for animation duration) to pixels per frame
        // For consistency: higher duration number = faster movement
        // CSS uses duration as duration (higher = slower), so we invert it for JS
        // Scale the calculation to make movement more visible
        container.scrollLeft += pixelsPerFrame * scrollDirection;
      }

      // Check if we need to reset the scroll position for infinite scrolling
      const maxScrollLeft = slide.scrollWidth - container.clientWidth;
      if (container.scrollLeft >= maxScrollLeft - pixelsPerFrame) {
        // jump back exactly one set
        container.scrollLeft -= slide.scrollWidth / clones;
      } else if (container.scrollLeft <= 0) {
        container.scrollLeft += slide.scrollWidth / clones;
      }

      animationFrame = requestAnimationFrame(updateScroll);
      activeAnimations.set(container, animationFrame);
    }

    const handleMouseOver = () => {
      isMouseOver = true;
      lastScrollPosition = container.scrollLeft;
    };

    const handleMouseOut = () => {
      isMouseOver = false;
      scrollDirection = 1;
    };

    const stopAnimation = () => {
      if (activeAnimations.has(container)) {
        cancelAnimationFrame(activeAnimations.get(container));
        activeAnimations.delete(container);
      }
    };

    container.addEventListener('mouseenter', handleMouseOver);
    container.addEventListener('mouseleave', handleMouseOut);

    // Add cleanup when container is removed from DOM
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((node) => {
          if (node === container || (node.nodeType === 1 && node.contains(container))) {
            stopAnimation();
            observer.disconnect();
          }
        });
      });
    });
    observer.observe(document.body, { childList: true, subtree: true });

    cloneLogos();
    animationFrame = requestAnimationFrame(updateScroll);
    activeAnimations.set(container, animationFrame);
  });
</script>

<style>
  @keyframes slide {
    from {
      transform: translateX(0);
    }
    to {
      transform: translateX(calc(-100% / 3));
    }
  }

  .logos-wrapper {
    position: relative;
    overflow: hidden;
    background: white;
  }

  .logos {
    --base-height: 100px;
    --base-padding: 30px;
    --base-max-width: 180px;
    --base-max-height: 80px;
    overflow: hidden;
    padding: calc(20px * var(--scale)) 0;
    background: white;
    white-space: nowrap;
    position: relative;
    z-index: 1;
    -webkit-mask-image: linear-gradient(
      to right,
      transparent,
      black 15%,
      black 85%,
      transparent
    );
    mask-image: linear-gradient(
      to right,
      transparent,
      black 15%,
      black 85%,
      transparent
    );
  }

  .logos-wrapper .blur-left,
  .logos-wrapper .blur-right {
    position: absolute;
    top: 0;
    width: calc(180px * var(--scale));
    height: 100%;
    z-index: 3;
    pointer-events: none;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .logos-wrapper .blur-left {
    left: calc(-30px * var(--scale));
    background: linear-gradient(to right, 
      white,
      rgba(255, 255, 255, 0.9) 20%,
      rgba(255, 255, 255, 0.7) 40%,
      rgba(255, 255, 255, 0.3) 60%,
      rgba(255, 255, 255, 0.1) 80%,
      transparent
    );
    -webkit-mask-image: linear-gradient(to right, white 50%, transparent);
    mask-image: linear-gradient(to right, white 50%, transparent);
  }

  .logos-wrapper .blur-right {
    right: calc(-30px * var(--scale));
    background: linear-gradient(to left,
      white,
      rgba(255, 255, 255, 0.9) 20%,
      rgba(255, 255, 255, 0.7) 40%,
      rgba(255, 255, 255, 0.3) 60%,
      rgba(255, 255, 255, 0.1) 80%,
      transparent
    );
    -webkit-mask-image: linear-gradient(to left, white 50%, transparent);
    mask-image: linear-gradient(to left, white 50%, transparent);
  }

  .logos-slide {
    display: inline-flex;
    animation: calc(var(--duration) * 1s) slide infinite linear;
  }

  .logos.pause-on-hover:hover .logos-slide {
    animation-play-state: paused;
  }

  .logos-slide a {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 calc(var(--base-padding) * var(--scale) / var(--client-scale));
  height: calc(var(--base-height) * var(--scale));
}

.logos-slide img {
  border-radius: 0;
  max-width: calc(var(--base-max-width) * var(--scale) * var(--client-scale));
  max-height: calc(var(--base-max-height) * var(--scale) * var(--client-scale));
  width: auto;
  height: auto;
  object-fit: contain;
  transform: scale(var(--client-scale));
  transition: transform 0.3s ease;
}

.logos-slide img:hover {
  transform: scale(calc(var(--client-scale) * 1.1));
}

  .logos.scrollable {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* Internet Explorer 10+ */
  }

  .logos.scrollable::-webkit-scrollbar {
    display: none; /* WebKit browsers (Safari, Chrome) */
  }

  .logos.scrollable:hover {
    overflow-x: scroll;
    -webkit-overflow-scrolling: touch;
  }

  .logos.scrollable .logos-slide {
    animation: none !important;
    display: flex;
    width: max-content;
  }




  @media (max-width: 960px) {
    .logos-slide a {
      padding: 0 calc(20px * var(--scale));
    }
    .logos-slide img {
      max-width: calc(120px * var(--scale));
      max-height: calc(60px * var(--scale));
    }
    
    .logos-wrapper .blur-left,
    .logos-wrapper .blur-right {
      width: calc(90px * var(--scale));
    }
  }
</style>